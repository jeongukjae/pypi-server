// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: package.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPackage = `-- name: CreatePackage :one
INSERT INTO package (name, summary, latest_version)
VALUES ($1, $2, $3)
RETURNING name, summary, latest_version, created_at, last_uploaded_at, updated_at
`

type CreatePackageParams struct {
	Name          string
	Summary       pgtype.Text
	LatestVersion pgtype.Text
}

func (q *Queries) CreatePackage(ctx context.Context, arg CreatePackageParams) (Package, error) {
	row := q.db.QueryRow(ctx, createPackage, arg.Name, arg.Summary, arg.LatestVersion)
	var i Package
	err := row.Scan(
		&i.Name,
		&i.Summary,
		&i.LatestVersion,
		&i.CreatedAt,
		&i.LastUploadedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createReleaseFile = `-- name: CreateReleaseFile :one
INSERT INTO release_file (
    version,
    package_name,
    file_name,
    file_type,
    file_path,
    file_size_bytes,
    pyversion,
    requires_python,
    requires_dist,
    md5_digest,
    sha256_digest,
    blake2_256_digest
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING version, package_name, file_name, file_type, file_path, file_size_bytes, pyversion, requires_python, requires_dist, md5_digest, sha256_digest, blake2_256_digest, created_at
`

type CreateReleaseFileParams struct {
	Version         string
	PackageName     string
	FileName        string
	FileType        string
	FilePath        string
	FileSizeBytes   int32
	Pyversion       pgtype.Text
	RequiresPython  pgtype.Text
	RequiresDist    []string
	Md5Digest       pgtype.Text
	Sha256Digest    pgtype.Text
	Blake2256Digest pgtype.Text
}

func (q *Queries) CreateReleaseFile(ctx context.Context, arg CreateReleaseFileParams) (ReleaseFile, error) {
	row := q.db.QueryRow(ctx, createReleaseFile,
		arg.Version,
		arg.PackageName,
		arg.FileName,
		arg.FileType,
		arg.FilePath,
		arg.FileSizeBytes,
		arg.Pyversion,
		arg.RequiresPython,
		arg.RequiresDist,
		arg.Md5Digest,
		arg.Sha256Digest,
		arg.Blake2256Digest,
	)
	var i ReleaseFile
	err := row.Scan(
		&i.Version,
		&i.PackageName,
		&i.FileName,
		&i.FileType,
		&i.FilePath,
		&i.FileSizeBytes,
		&i.Pyversion,
		&i.RequiresPython,
		&i.RequiresDist,
		&i.Md5Digest,
		&i.Sha256Digest,
		&i.Blake2256Digest,
		&i.CreatedAt,
	)
	return i, err
}

const getPackage = `-- name: GetPackage :one
SELECT
    name,
    summary,
    latest_version
FROM package
WHERE name = $1
`

type GetPackageRow struct {
	Name          string
	Summary       pgtype.Text
	LatestVersion pgtype.Text
}

func (q *Queries) GetPackage(ctx context.Context, name string) (GetPackageRow, error) {
	row := q.db.QueryRow(ctx, getPackage, name)
	var i GetPackageRow
	err := row.Scan(&i.Name, &i.Summary, &i.LatestVersion)
	return i, err
}

const getPackageByName = `-- name: GetPackageByName :one
SELECT
    name,
    summary,
    latest_version,
    created_at,
    last_uploaded_at,
    updated_at
FROM
    package
WHERE
    name = $1
`

func (q *Queries) GetPackageByName(ctx context.Context, name string) (Package, error) {
	row := q.db.QueryRow(ctx, getPackageByName, name)
	var i Package
	err := row.Scan(
		&i.Name,
		&i.Summary,
		&i.LatestVersion,
		&i.CreatedAt,
		&i.LastUploadedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRelease = `-- name: GetRelease :one
SELECT
    version,
    package_name
FROM
    release
WHERE
    package_name = $1 AND version = $2
`

type GetReleaseParams struct {
	PackageName string
	Version     string
}

type GetReleaseRow struct {
	Version     string
	PackageName string
}

func (q *Queries) GetRelease(ctx context.Context, arg GetReleaseParams) (GetReleaseRow, error) {
	row := q.db.QueryRow(ctx, getRelease, arg.PackageName, arg.Version)
	var i GetReleaseRow
	err := row.Scan(&i.Version, &i.PackageName)
	return i, err
}

const getReleaseFileByName = `-- name: GetReleaseFileByName :one
SELECT
    version,
    file_name,
    file_path
FROM
    release_file
WHERE
    package_name = $1 AND file_name = $2
`

type GetReleaseFileByNameParams struct {
	PackageName string
	FileName    string
}

type GetReleaseFileByNameRow struct {
	Version  string
	FileName string
	FilePath string
}

func (q *Queries) GetReleaseFileByName(ctx context.Context, arg GetReleaseFileByNameParams) (GetReleaseFileByNameRow, error) {
	row := q.db.QueryRow(ctx, getReleaseFileByName, arg.PackageName, arg.FileName)
	var i GetReleaseFileByNameRow
	err := row.Scan(&i.Version, &i.FileName, &i.FilePath)
	return i, err
}

const listPackagesSimple = `-- name: ListPackagesSimple :many
SELECT
    name
FROM
    package
`

func (q *Queries) ListPackagesSimple(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listPackagesSimple)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReleaseFilesByPackageNameSimple = `-- name: ListReleaseFilesByPackageNameSimple :many
SELECT
    version,
    file_name,
    file_type,
    md5_digest,
    sha256_digest,
    blake2_256_digest,
    requires_python
FROM
    release_file
WHERE
    package_name = $1
ORDER BY
    created_at DESC
`

type ListReleaseFilesByPackageNameSimpleRow struct {
	Version         string
	FileName        string
	FileType        string
	Md5Digest       pgtype.Text
	Sha256Digest    pgtype.Text
	Blake2256Digest pgtype.Text
	RequiresPython  pgtype.Text
}

func (q *Queries) ListReleaseFilesByPackageNameSimple(ctx context.Context, packageName string) ([]ListReleaseFilesByPackageNameSimpleRow, error) {
	rows, err := q.db.Query(ctx, listReleaseFilesByPackageNameSimple, packageName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListReleaseFilesByPackageNameSimpleRow
	for rows.Next() {
		var i ListReleaseFilesByPackageNameSimpleRow
		if err := rows.Scan(
			&i.Version,
			&i.FileName,
			&i.FileType,
			&i.Md5Digest,
			&i.Sha256Digest,
			&i.Blake2256Digest,
			&i.RequiresPython,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePackageDescription = `-- name: UpdatePackageDescription :one
UPDATE package
SET summary = $2, updated_at = NOW()
WHERE name = $1
RETURNING name, summary, latest_version, created_at, last_uploaded_at, updated_at
`

type UpdatePackageDescriptionParams struct {
	Name    string
	Summary pgtype.Text
}

func (q *Queries) UpdatePackageDescription(ctx context.Context, arg UpdatePackageDescriptionParams) (Package, error) {
	row := q.db.QueryRow(ctx, updatePackageDescription, arg.Name, arg.Summary)
	var i Package
	err := row.Scan(
		&i.Name,
		&i.Summary,
		&i.LatestVersion,
		&i.CreatedAt,
		&i.LastUploadedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePackageLatestVersion = `-- name: UpdatePackageLatestVersion :exec
UPDATE
    package
SET
    summary = $2,
    latest_version = $3,
    last_uploaded_at = NOW(),
    updated_at = NOW()
WHERE
    name = $1
`

type UpdatePackageLatestVersionParams struct {
	Name          string
	Summary       pgtype.Text
	LatestVersion pgtype.Text
}

func (q *Queries) UpdatePackageLatestVersion(ctx context.Context, arg UpdatePackageLatestVersionParams) error {
	_, err := q.db.Exec(ctx, updatePackageLatestVersion, arg.Name, arg.Summary, arg.LatestVersion)
	return err
}

const upsertRelease = `-- name: UpsertRelease :one
INSERT INTO release (
    version,
    package_name,
    metadata_version,
    summary,
    description,
    description_content_type
) VALUES (
    $1, $2, $3, $4, $5, $6
) ON CONFLICT (package_name, version) DO UPDATE SET
    metadata_version = EXCLUDED.metadata_version,
    summary = EXCLUDED.summary,
    description = EXCLUDED.description,
    description_content_type = EXCLUDED.description_content_type,
    updated_at = NOW()
RETURNING version, package_name, metadata_version, summary, description, description_content_type, created_at, updated_at, yanked, yanked_reason, yanked_at
`

type UpsertReleaseParams struct {
	Version                string
	PackageName            string
	MetadataVersion        string
	Summary                pgtype.Text
	Description            pgtype.Text
	DescriptionContentType pgtype.Text
}

func (q *Queries) UpsertRelease(ctx context.Context, arg UpsertReleaseParams) (Release, error) {
	row := q.db.QueryRow(ctx, upsertRelease,
		arg.Version,
		arg.PackageName,
		arg.MetadataVersion,
		arg.Summary,
		arg.Description,
		arg.DescriptionContentType,
	)
	var i Release
	err := row.Scan(
		&i.Version,
		&i.PackageName,
		&i.MetadataVersion,
		&i.Summary,
		&i.Description,
		&i.DescriptionContentType,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Yanked,
		&i.YankedReason,
		&i.YankedAt,
	)
	return i, err
}
