// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuditLog = `-- name: CreateAuditLog :one
INSERT INTO audit_log (user_id, action, details)
VALUES ($1, $2, $3)
RETURNING id, user_id, action, details, created_at
`

type CreateAuditLogParams struct {
	UserID  pgtype.Int4
	Action  string
	Details pgtype.Text
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (AuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog, arg.UserID, arg.Action, arg.Details)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Action,
		&i.Details,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO "user" (username, password_hash)
VALUES ($1, $2)
RETURNING id, username, created_at, updated_at
`

type CreateUserParams struct {
	Username     string
	PasswordHash string
}

type CreateUserRow struct {
	ID        int32
	Username  string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.PasswordHash)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAccessToken = `-- name: DeleteAccessToken :exec
DELETE FROM access_token
WHERE id = $1
`

func (q *Queries) DeleteAccessToken(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAccessToken, id)
	return err
}

const getAccessTokenByHash = `-- name: GetAccessTokenByHash :one
SELECT id, user_id, token_hash, expires_at, created_at
FROM access_token
WHERE token_hash = $1
`

type GetAccessTokenByHashRow struct {
	ID        int32
	UserID    int32
	TokenHash string
	ExpiresAt pgtype.Timestamptz
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) GetAccessTokenByHash(ctx context.Context, tokenHash string) (GetAccessTokenByHashRow, error) {
	row := q.db.QueryRow(ctx, getAccessTokenByHash, tokenHash)
	var i GetAccessTokenByHashRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRoleByAccessTokenID = `-- name: GetRoleByAccessTokenID :one
SELECT r.id, r.name, r.description
FROM role r
JOIN access_token_role atr ON r.id = atr.role_id
WHERE atr.access_token_id = $1
`

type GetRoleByAccessTokenIDRow struct {
	ID          int32
	Name        string
	Description pgtype.Text
}

func (q *Queries) GetRoleByAccessTokenID(ctx context.Context, accessTokenID int32) (GetRoleByAccessTokenIDRow, error) {
	row := q.db.QueryRow(ctx, getRoleByAccessTokenID, accessTokenID)
	var i GetRoleByAccessTokenIDRow
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getRoleByUserID = `-- name: GetRoleByUserID :one
SELECT r.id, r.name, r.description
FROM role r
JOIN user_role ur ON r.id = ur.role_id
WHERE ur.user_id = $1
`

type GetRoleByUserIDRow struct {
	ID          int32
	Name        string
	Description pgtype.Text
}

func (q *Queries) GetRoleByUserID(ctx context.Context, userID int32) (GetRoleByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getRoleByUserID, userID)
	var i GetRoleByUserIDRow
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getUserByName = `-- name: GetUserByName :one
SELECT id, username, password_hash, created_at, updated_at
FROM "user"
WHERE username = $1
`

type GetUserByNameRow struct {
	ID           int32
	Username     string
	PasswordHash string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
}

func (q *Queries) GetUserByName(ctx context.Context, username string) (GetUserByNameRow, error) {
	row := q.db.QueryRow(ctx, getUserByName, username)
	var i GetUserByNameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAccessTokenRole = `-- name: UpdateAccessTokenRole :exec
INSERT INTO access_token_role (access_token_id, role_id)
VALUES ($1, (SELECT id FROM role WHERE name = $2))
ON CONFLICT (access_token_id) DO UPDATE SET role_id = EXCLUDED.role_id
`

type UpdateAccessTokenRoleParams struct {
	AccessTokenID int32
	Name          string
}

func (q *Queries) UpdateAccessTokenRole(ctx context.Context, arg UpdateAccessTokenRoleParams) error {
	_, err := q.db.Exec(ctx, updateAccessTokenRole, arg.AccessTokenID, arg.Name)
	return err
}

const updateUserRole = `-- name: UpdateUserRole :exec
INSERT INTO user_role (user_id, role_id)
VALUES ($1, (SELECT id FROM role WHERE name = $2))
ON CONFLICT (user_id) DO UPDATE SET role_id = EXCLUDED.role_id
`

type UpdateUserRoleParams struct {
	UserID int32
	Name   string
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.Exec(ctx, updateUserRole, arg.UserID, arg.Name)
	return err
}
